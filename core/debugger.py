"""
STITCHER-CORE: AGENTIC SELF-HEALING ENGINE
Author: Faith Adeniyi
Architecture: Deterministic Diagnostic & Surgical Injection Layer

This module implements a 'Self-Healing' loop designed to intercept and repair 
structural hallucinations in LLM-generated UI components without re-inference.
"""

import logging
import re
from typing import List

class AgenticDebugger:
    def __init__(self):
        """
        Initializes the debugger with pre-compiled regex patterns.
        Pre-compiling patterns in the constructor optimizes performance for 
        high-frequency build cycles.
        """
        self.logger = logging.getLogger("StitcherCore.Debugger")
        
        # Professional-grade Regex patterns for structural analysis
        self._patterns = {
            "DIV_OPEN": re.compile(r"<div", re.IGNORECASE),
            "DIV_CLOSE": re.compile(r"</div", re.IGNORECASE),
            "EMPTY_CLASS": re.compile(r'class=["\']\s*["\']', re.IGNORECASE),
            "TRUNCATED_TAG": re.compile(r'<[^>]*$') # Detects tags cut off at the end
        }

    def run_diagnostic(self, html_payload: str) -> List[str]:
        """
        Performs a forensic scan of the HTML payload to identify structural defects.
        
        Args:
            html_payload (str): The raw code string generated by the LLM.
            
        Returns:
            List[str]: A collection of 'Error Fingerprints' found during the scan.
        """
        self.logger.info("Initiating structural diagnostic scan...")
        diagnostics = []

        # 1. Structural Integrity Check: Div Balancing
        open_tags = len(self._patterns["DIV_OPEN"].findall(html_payload))
        close_tags = len(self._patterns["DIV_CLOSE"].findall(html_payload))
        
        if open_tags != close_tags:
            self.logger.warning(f"Structural Mismatch Detected: {open_tags} open / {close_tags} closed.")
            diagnostics.append("DIV_MISMATCH")

        # 2. Syntax Cleanup: Empty Tailwind Attributes
        if self._patterns["EMPTY_CLASS"].search(html_payload):
            diagnostics.append("EMPTY_CLASSES")

        # 3. Edge Case: Truncated Endings
        if self._patterns["TRUNCATED_TAG"].search(html_payload):
            diagnostics.append("TRUNCATED_OUTPUT")

        return diagnostics

    def autonomous_patch(self, html_payload: str, diagnostics: List[str]) -> str:
        """
        Applies surgical patches to the payload based on identified fingerprints.
        This prevents expensive LLM re-prompts and maintains system throughput.
        """
        patched_output = html_payload

        for issue in diagnostics:
            if issue == "DIV_MISMATCH":
                # Inject missing closing tags to protect DOM structure
                patched_output += "\n</div> "
            
            elif issue == "EMPTY_CLASSES":
                # Remove redundant empty class strings for cleaner production code
                patched_output = self._patterns["EMPTY_CLASS"].sub('', patched_output)
            
            elif issue == "TRUNCATED_OUTPUT":
                # Force-close any tags left open by token limits
                patched_output += ">"

            self.logger.info(f"Surgical patch successfully applied for: {issue}")

        return patched_output
