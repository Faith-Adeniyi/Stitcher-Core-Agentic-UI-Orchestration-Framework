import logging
import re
import json
import os
from typing import List

class AgenticDebugger:
    """
    SELF-HEALING ENGINE:
    Implements a deterministic diagnostic and surgical injection layer to repair 
    structural defects in LLM-generated UI components. Ensures production-grade 
    output integrity without redundant inference cycles.
    """
    def __init__(self, config=None, manifest_path="project_manifest.json"):
        """
        Initializes the Debugger utilizing decoupled parameters from the global manifest.
        """
        self.logger = logging.getLogger("StitcherCore.Debugger")
        
        # Load configuration from manifest for scalability
        if config is None and os.path.exists(manifest_path):
            try:
                with open(manifest_path, 'r') as f:
                    full_manifest = json.load(f)
                    self.config = full_manifest.get("debugger_settings", {})
            except Exception as e:
                self.logger.error(f"Manifest loading failed: {e}")
                self.config = {}
        else:
            self.config = config or {}

        # Dynamically compile patterns based on configuration
        self.enforced_tags = self.config.get("enforced_tags", ["div"])
        self._patterns = {
            "EMPTY_CLASS": re.compile(r'class=["\']\s*["\']', re.IGNORECASE),
            "TRUNCATED_TAG": re.compile(r'<[^>]*$')
        }

    def run_diagnostic(self, html_payload: str) -> List[str]:
        """
        Performs a forensic structural scan of the HTML payload to identify defects.
        
        Args:
            html_payload (str): The raw code string generated by the AI agent.
            
        Returns:
            List[str]: A collection of detected error fingerprints.
        """
        self.logger.info("Debugger: Commencing structural diagnostic sequence...")
        diagnostics = []

        # 1. Structural Integrity: Tag Balancing for configured tags
        for tag in self.enforced_tags:
            open_count = len(re.findall(f"<{tag}", html_payload, re.IGNORECASE))
            close_count = len(re.findall(f"</{tag}", html_payload, re.IGNORECASE))
            
            if open_count != close_count:
                self.logger.warning(f"Integrity Mismatch: <{tag}> ({open_count} open / {close_count} closed)")
                diagnostics.append(f"MISMATCH_{tag.upper()}")

        # 2. Syntax Validation: Empty Attribute Strings
        if self.config.get("clean_empty_classes") and self._patterns["EMPTY_CLASS"].search(html_payload):
            diagnostics.append("EMPTY_CLASSES")

        # 3. Buffer Check: Truncated Output Detection
        if self.config.get("repair_truncated_tags") and self._patterns["TRUNCATED_TAG"].search(html_payload):
            diagnostics.append("TRUNCATED_OUTPUT")

        return diagnostics

    def autonomous_patch(self, html_payload: str, diagnostics: List[str]) -> str:
        """
        Applies non-destructive surgical patches based on identified fingerprints.
        Maintains system throughput by resolving hallucinations programmatically.
        """
        patched_output = html_payload

        for issue in diagnostics:
            # Handle Tag Mismatches dynamically
            if issue.startswith("MISMATCH_"):
                tag = issue.split("_")[1].lower()
                patched_output += f"\n</{tag}>"
            
            elif issue == "EMPTY_CLASSES":
                patched_output = self._patterns["EMPTY_CLASS"].sub('', patched_output)
            
            elif issue == "TRUNCATED_OUTPUT":
                patched_output += ">"

            self.logger.info(f"Debugger: Surgical patch applied for {issue}")

        return patched_output

if __name__ == "__main__":
    # Internal Unit Test
    test_html = "<div class=''><h1>Agentic UI</h1>"
    debugger = AgenticDebugger()
    reports = debugger.run_diagnostic(test_html)
    print(f"Diagnostics: {reports}")
    print(f"Patched: {debugger.autonomous_patch(test_html, reports)}")